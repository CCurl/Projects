************************************
*     s5 Reference                 *
************************************

*** ARITHMETIC ***
+  (a b--a+b)     addition
-  (a b--a-b)     subtraction
*  (a b--a*b)     multiplication
/  (a b--a/b)     division
K  (T--n)         multiply TOS by 1000
O  (T--n)         set TOS to (-T)
P  (T--n)         increment TOS by 1
Q  (T--n)         decrement TOS by 1
S  (a n--q r)     q: a/n, r: a MODULO n (SLASHMOD)
U  (T--n)         set TOS the absolute value of T


*** BIT MANIPULATION ***
&    (a b--n)     and
|    (a b--n)     or
XOR  (a b--n)     xor
F    (n1--n2)     flip bits: (one's complement) (e.e - 1011 => 0100)
R    (V N--T)     T: V shift-right N
L    (V N--T)     T: V shift-left N


*** STACK ***
#  (a--a a)       Duplicate TOS                          (Forth DUP)
\  (a b--a)       Drop TOS                               (Forth DROP)
$  (a b--b a)     Swap top 2 stack items                 (Forth SWAP)
%  (a b--a b a)   Push 2nd                               (Forth OVER)
XS (?--)          Clear the stack, remove all entries    (Forth 0SP)


*** MEMORY ***
  NOTEs: There are 3 address spaces, CODE, VAR, and ABSOLUTE
         CODE and MEMORY addresses are indexes into that specific area of memory
         ABSOLUTE addresses are the addresses of the entire machine

       E.G. - '7 4 * c@' returns the lowest byte of HERE
C@    (a--n)      Fetch byte n from VAR address a
C!    (n a--)     Store byte n  to  VAR address a
D@    (a--n)      Fetch byte n from CODE address a
D!    (n a--)     Store byte n  to  CODE address a
A@    (a--n)      Fetch byte n from ABSOLUTE address a
A!    (n a--)     Store byte n  to  ABSOLUTE address a
M@    (a--n)      Fetch long n from ABSOLUTE address a
M!    (n a--)     Store long n  to  ABSOLUTE address a
@     (a--n)      Fetch long from VAR address a
!     (n a--)     Store long n to VAR address a


*** REGISTERS ***
  NOTES: The registers are stored in beginning of the VAR addresses: aa = VAR[0]
         A register is exactly 2 lowercase alpha characters: [aa .. zz]
         The maximun number of registers is 26*26 = 676 registers.
         Register initial values:
         - ca: Size of CODE area
         - da: Start of CODE area
         - ha: HERE **special**
         - ma: Start of VARS area
         - sa: Start of system structure
         - va: First available VAR address (byte address)
         - za: Size of VARS area
         - All other registers set to 0
xx:  (n--)         Set register xx value to n
xx   (--n)         Push value of register xx (X:[A..Z])
xx+  (--n)         Push value of register xx, then increment the register by 1
xx-  (--n)         Push value of register xx, then decrement the register by 1

*** Quotes ***
      NOTES: Quotes are un-named code entities.
{   (--n)    Begins a quote. Push first char after the '{' on the stack.
}            Ends a quote.

*** INPUT/OUTPUT ***
.     (N--)       Output N as decimal number
,     (N--)       Output N as character (Forth EMIT)
B     (--)        Output a BLANK (32,)
N     (--)        Output a NEWLINE (13,10,)
Y     (N--)       Load code from block (Filename is block.NNN)
Z     (A--)       Output the NULL terminated string at A.
"     (--)        Output characters until next '"'
_     (a1--a2)    String: copy string to address (a1) (eg - 1000_Hello World!_)
                      Pushes address (a2) after terminating NULL
`     (a--)       Code: copy bytes to CODE[ha+] (eg - ha`{"Hello World!"}pg:`^)
HX    (--n)       Scan HEX number X until non-HEX digit (not case-sensitive, H3Da0 == H3dA0 )
0..9  (--n)       Scan DECIMAL number until non digit
                     to specify multiple values, separate them by space (4711 3333)
                     to enter a negative number, use 'o' (eg - '32o')
'x   (--n)        Push the ascii value of x (x: [any char possible])


*** CONDITIONS/FLOW CONTROL ***
<   (a b--f)      f: (a < b) ? 1 : 0;
=   (a b--f)      f: (a = b) ? 1 : 0;
>   (a b--f)      f: (a > b) ? 1 : 0;
~   (x--f)        f: (x = 0) ? 1 : 0;
?   (F Q1 Q2--)   If (F != 0), execute code as Q1, else execute Q2 if it is not 0.
[   (F T --)      FOR: start a For/Next loop. if (T < F), swap F and T 
]   ( -- )        NEXT: increment index (xI) and loop if (xI < T)
          NOTE: For loops CAN be nested
I   (-- n)        Index: push the index of the current FOR loop
J   (-- n)        Index: push the index of the 1st inner FOR loop
(   (F--F)        BEGIN: if (F==0), skip code until ')'
)   (F--)         WHILE: if (F != 0), jump to the BEGIN (no drop), else drop F and continue.
          NOTES: 1. You can NOT nest LOOPs
                 2. '()' cannot have a ')' embedded in it. Example: aa("TE)ST"1-) fails when aa=0.
                    USE aa("TE"93,"ST"1-) instead.
^   (T--)    Call code at address T.
E   (T--)    Execute address T without return.


*** OTHER ***
T      (--n)        Time (Arduino: millis(), Windows: GetTickCount())
W      (n--)        Wait (Arduino: delay(),  Windows: Sleep())
XFO    (fn md--fh)  PC-File: open (fn/md: addr of name/mode, use `S"")
XFR    (fh--c n)    PC-File: read 1 char (n=0 means EOF)
XFW    (c fh--)     PC-File: write 1 char
XFC    (fh--)       PC-File: close
XIA    (--)         Info: All (CFMRS)
XIC    (--)         Info: Code
XIR    (--)         Info: Registers
XIS    (--)         Info: Stack
XPI    (p--)        Arduino: pin input  (pinMode(p, INPUT))
XPU    (p--)        Arduino: pin pullup (pinMode(p, INPUT_PULLUP))
XPO    (p--)        Arduino: pin output (pinMode(p, OUTPUT)
XPRA   (p--n)       Arduino: pin read analog  (n = analogRead(p))
XPRD   (p--n)       Arduino: pin read digital (n = digitalRead(p))
XPWA   (n p--)      Arduino: pin write analog  (analogWrite(p, n))
XPWD   (n p--)      Arduino: pin write digital (digitalWrite(p, n))
XT     (--)         Exit S4
XR     (--)         Reset S4 to initial state

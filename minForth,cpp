// MinForth.cpp : An extremely memory conscious Forth interpreter
//

#include <stdio.h>

typedef unsigned char byte;
typedef short CELL;
typedef unsigned short UCELL;

#define MEM_SZ 100
#define STK_SZ   8

typedef struct {
    CELL next;
    CELL xt;
    byte flags;
    char name[16];
} dict_t;

typedef struct {
    CELL pc;
    CELL last;
    CELL here;
    CELL lhere;
    CELL vhere;
    byte ir;
    byte base;
    byte dsp;
    byte rsp;
    CELL dstack[STK_SZ];
    CELL rstack[STK_SZ];
    byte mem[MEM_SZ];
} sys_t;

sys_t sys;

#define PC   sys.pc
#define IR   sys.ir
#define DSTK sys.dstack
#define RSTK sys.rstack
#define DSP  sys.dsp
#define RSP  sys.rsp
#define MEM  sys.mem
#define BASE sys.base
#define HERE sys.here
#define LHERE sys.lhere
#define VHERE sys.vhere
#define LAST sys.last

#define GET_CELL(l) (MEM[l] | (MEM[l+1]<<8))
#define SET_CELL(l, v) MEM[l] = (v&0xff); MEM[l+1] = (v>>8)
#define BYTE_AT(x) (MEM[x])
#define STR_AT(x) (char *)&MEM[x]
#define DE_AT(x) (dict_t *)&MEM[x]

#define T DSTK[DSP]
#define SN(x) (x % STK_SZ)

#define CCOMMA(x) MEM[HERE++] = x
#define VCCOMMA(x) MEM[VHERE++] = x

void push(CELL v) { DSP = SN(DSP + 1);  DSTK[DSP] = v; }
CELL pop() { CELL x = T; DSP = SN(DSP - 1);  return x; }

void rpush(CELL v) { RSP = SN(RSP + 1);  RSTK[RSP] = v; }
CELL rpop() { CELL x = T; RSP = SN(RSP - 1);  return x; }

inline void cComma() { CCOMMA((byte)pop()); }

void Comma(CELL v) {
    SET_CELL(HERE, v);
    HERE += 2;
}

byte strEq(const char* x, const char* y) {
    while (*x && *y && (*x == *y)) {
        ++x; ++y;
    }
    return (*x || *y) ? 0 : 1;
}

int strLen(const char* str) {
    int l = 0;
    while (*str) {
        l++;
        str++;
    }
    return l;
}

void strCpy(char* d, const char* s) {
    while (*s) { *(d++) = *(s++); }
    *d = 0;
}

void doCreate(const char* name, byte f) {
    dict_t* dp = DE_AT(LHERE);
    dp->next = LAST;
    dp->flags = f;
    strCpy(dp->name, name);
    LAST = LHERE;
    LHERE = strLen(name) + LHERE + 6;
    dp->xt = HERE;
}

dict_t* doFind(const char* name) {
    dict_t* dp = DE_AT(LAST);
    while (dp) {
        if (strEq(dp->name, name)) { return dp; }
        if (dp->next) { dp = DE_AT(dp->next); }
        else { dp = NULL; }
    }
    return dp;
}

void str2Here(const char* str) {
    while (*str) {
        CCOMMA(*(str++));
    }
}

int isDigit(char c) {
    if (('0' <= c) && (c <= '9')) { return c - '0'; }
    return -1;
}

CELL doNum(CELL pc) {
    int c = isDigit(MEM[pc]);
    while (0 <= c) {
        T = (T * 10) + c;
        c = isDigit(MEM[++pc]);
    }
    return pc;
}

void reset() {
    DSP = 0;
    RSP = 0;
    BASE = 10;
    HERE = 2;
    LAST = 0;
    LHERE = 50;
    VHERE = 30;
}

void run(CELL start) {
    PC = start;
    CELL t1, t2;
    while (1) {
        IR = MEM[PC++];
        switch (IR) {
        case 0: return;
        case ' ': break;
        case '#': push(T);                   break;
        case '\\': pop();                    break;
        case '+': t1 = pop(); T += t1;       break;
        case '.': printf("%d", pop());       break;
        case ',': printf("%c", (byte)pop()); break;
        case 'b': printf(" ");               break;
        case 'n': printf("\r\n");            break;
        case '$': t1 = pop(); t2 = pop();
            push(t1); push(t2);
            break;
        case '%': t1 = pop(); t2 = T;
            push(t1); push(t2);
            break;
        case ';': return;                    break;
        case '0': case '1': case '2': case '3': case '4':
        case '5': case '6': case '7': case '8': case '9':
            push(isDigit(IR));
            PC = doNum(PC);
            break;
        }
    }
}

int main()
{
    printf("mem usage: %d", sizeof(sys));
    reset();
    doCreate("CELL", 0);
    str2Here("2;");
    doCreate("EMIT", 1);
    str2Here(",;");
    dict_t* dp = doFind("CELL");
    if (dp) { run(dp->xt); }
    push(78);
    dp = doFind("EMIT");
    if (dp) { run(dp->xt); }
    CELL x = HERE;
    str2Here("b1 2 3++.");
    run(x);
}

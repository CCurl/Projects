// MinForth.cpp : An extremely memory conscious Forth interpreter
//

#include <stdio.h>

typedef unsigned char byte;
typedef short CELL;
typedef unsigned short UCELL;

#define MEM_SZ  200
#define STK_SZ    8
#define LH_INIT  70
#define VH_INIT  50


typedef struct {
    CELL next;
    CELL xt;
    byte flags;
    char name[16];
} dict_t;

typedef struct {
    CELL pc;
    CELL last;
    CELL here;
    CELL lhere;
    CELL vhere;
    byte ir;
    byte base;
    byte dsp;
    byte rsp;
    CELL dstack[STK_SZ];
    CELL rstack[STK_SZ];
    byte mem[MEM_SZ];
} sys_t;

sys_t sys;

#define PC   sys.pc
#define IR   sys.ir
#define DSTK sys.dstack
#define RSTK sys.rstack
#define DSP  sys.dsp
#define RSP  sys.rsp
#define MEM  sys.mem
#define BASE sys.base
#define HERE sys.here
#define LHERE sys.lhere
#define VHERE sys.vhere
#define LAST sys.last

#define GET_CELL(l) (MEM[l] | (MEM[l+1]<<8))
#define SET_CELL(l, v) MEM[l] = (v&0xff); MEM[l+1] = (v>>8)
#define BYTE_AT(x) (MEM[x])
#define STR_AT(x) (char *)&MEM[x]
#define DP_AT(x) (dict_t *)&MEM[x]

#define T DSTK[DSP]
#define SN(x) (x % STK_SZ)

#define CCOMMA(x) MEM[HERE++] = x
#define VCCOMMA(x) MEM[VHERE++] = x

void push(CELL v) { DSP = SN(DSP + 1);  DSTK[DSP] = v; }
CELL pop() { CELL x = T; DSP = SN(DSP - 1);  return x; }

void rpush(CELL v) { RSP = SN(RSP + 1);  RSTK[RSP] = v; }
CELL rpop() { CELL x = T; RSP = SN(RSP - 1);  return x; }

inline void cComma() { CCOMMA((byte)pop()); }

void Comma(CELL v) {
    SET_CELL(HERE, v);
    HERE += 2;
}

byte strEq(const char* x, const char* y) {
    while (*x && *y && (*x == *y)) {
        ++x; ++y;
    }
    return (*x || *y) ? 0 : 1;
}

int strLen(const char* str) {
    int l = 0;
    while (*str) {
        l++;
        str++;
    }
    return l;
}

void strCpy(char* d, const char* s) {
    while (*s) { *(d++) = *(s++); }
    *d = 0;
}

void doCreate(const char* name, byte f) {
    dict_t* dp = DP_AT(LHERE);
    dp->next = LAST;
    dp->xt = HERE;
    dp->flags = f;
    strCpy(dp->name, name);
    LAST = LHERE;
    LHERE = strLen(name) + LHERE + 6;
}

dict_t* doFind(const char* name) {
    dict_t* dp = DP_AT(LAST);
    while (dp) {
        if (strEq(dp->name, name)) { return dp; }
        if (dp->next) { dp = DP_AT(dp->next); }
        else { dp = NULL; }
    }
    return dp;
}

void doWords() {
    dict_t* dp = DP_AT(LAST);
    while (dp) {
        printf("%s ", dp->name);
        if (dp->next) { dp = DP_AT(dp->next); }
        else { dp = NULL; }
    }
}

void str2Here(const char* str) {
    while (*str) {
        CCOMMA(*(str++));
    }
}

int isDigit(char c) {
    if (('0' <= c) && (c <= '9')) { return c - '0'; }
    return -1;
}

CELL doNum(CELL pc) {
    int c = isDigit(MEM[pc]);
    while (0 <= c) {
        T = (T * 10) + c;
        c = isDigit(MEM[++pc]);
    }
    return pc;
}

void reset() {
    DSP = 0;
    RSP = 0;
    BASE = 10;
    HERE = 2;
    LAST = 0;
    LHERE = LH_INIT;
    VHERE = VH_INIT;
}

void run(CELL start) {
    PC = start;
    CELL t1, t2;
    while (1) {
        IR = MEM[PC++];
        switch (IR) {
        case 0: return;
        case ' ': break;
        case '#': push(T);                   break;
        case '\\': pop();                    break;
        case '+': t1 = pop(); T += t1;       break;
        case '-': t1 = pop(); T -= t1;       break;
        case '*': t1 = pop(); T *= t1;       break;
        case '/': t1 = pop(); T /= t1;       break;
        case '.': printf("%d", pop());       break;
        case ',': printf("%c", (byte)pop()); break;
        case 'b': printf(" ");               break;
        case 'n': printf("\r\n");            break;
        case 'W': doWords();                 break;
        case '$': t1 = pop(); t2 = pop();    // SWAP
            push(t1); push(t2);
            break;
        case '%': t1 = pop(); t2 = T;        // OVER
            push(t1); push(t2);
            break;
        case ';': return;                    break;
        case '0': case '1': case '2': case '3': case '4':
        case '5': case '6': case '7': case '8': case '9':
            push(isDigit(IR));
            PC = doNum(PC);
            break;
        }
    }
}

void doBuiltin(const char* name, byte flags, const char* code) {
    doCreate(name, flags);
    str2Here(code);
    CCOMMA(';');
}

int main()
{
    CELL x;
    dict_t* dp;
    printf("mem usage: %d\n", sizeof(sys));
    reset();
    x = HERE; str2Here("1 2 3++."); HERE = x; run(HERE);
    doBuiltin("CELL", 1, "2 ");
    doBuiltin("SWAP", 1, "$");
    doBuiltin("DROP", 1, "\\");
    doBuiltin("DUP",  1, "#");
    doBuiltin("OVER", 1, "%");
    doBuiltin("EMIT", 1, ",");
    doBuiltin("WORDS", 1, "W");
    doBuiltin("CR", 1, "n");
    doBuiltin(".", 1, ".");
    doBuiltin("+", 1, "+");
    doBuiltin("-", 1, "-");
    doBuiltin("*", 1, "*");
    doBuiltin("/", 1, "/");
    push(78);
    dp = doFind("CR");    if (dp) { run(dp->xt); }
    dp = doFind("WORDS"); if (dp) { run(dp->xt); }
    dp = doFind("CR");    if (dp) { run(dp->xt); }
    dp = doFind("EMIT");  if (dp) { run(dp->xt); }
    x = HERE; str2Here(""); HERE = x; run(HERE);
}
